/*
~ Author    : https://leetcode.com/tridib_2003/
~ Problem   : 924. Minimize Malware Spread
~ Link      : https://leetcode.com/problems/minimize-malware-spread/
*/

class Solution {
public:
    vector<int> parents;

    int find(int x) {
        if (x != parents[x])
            parents[x] = find(parents[x]);
        return parents[x];
    }

    void performUnion(int x, int y) {
        parents[find(x)] = find(y);
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {

        int totalNodes = graph.size();

        for (int i = 0; i < totalNodes; ++i) {
            parents.emplace_back(i);
        }

        // Perform union of all nodes
        for (int i = 0; i < totalNodes; ++i) {
            for (int j = i + 1; j < totalNodes; ++j) {
                if (graph[i][j] == 1)
                    performUnion(i,j);
            }
        }

        // Get the number of nodes in a component
        vector<int> componentSize(totalNodes, 0);
        for (int i = 0; i < totalNodes; ++i)
            ++componentSize[find(i)];

        // Get the malware count in each component
        vector<int> malwareCount(totalNodes, 0);
        for (int i = 0; i < initial.size(); ++i) {
            ++malwareCount[find(initial[i])];
        }

        sort(initial.begin(), initial.end());

        int res = initial[0], currSize = 0;

        for (int i : initial) {

            int idx = find(i);

            // Only one malware node should be present in the component, also
            // node in component with largest size and min. index is result
            if (malwareCount[idx] == 1 && componentSize[idx] > currSize) {
                res = i;
                currSize = componentSize[idx];
            }
        }

        return res;
    }
};
